# -*- coding: utf-8 -*-
"""Zeichnung.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I2bQOpyGi4Qw-5RY15JDYT5BxyV6beaT
"""

# === RFFG 4x4 2D-Torus als 3D-Szene mit USB-IN/OUT und bidirektionalen Links ===
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 (needed to activate 3D)
from matplotlib.lines import Line2D

# ---------------- Styling / Parameter ----------------
N = 3                   # Gridgröße (N x N)
H = 0.9                 # USB-Pfeilhöhe (z-Versatz)
NODE_MS = 12             # Knotengröße (Marker size)
EDGE_W = 1.2            # Linienstärke lokale Kanten
WRAP_W = 1.8            # Linienstärke Wrap-Kanten
ARHEAD = 0.25           # Länge der Pfeilköpfe (in Plot-Koordinaten)
USB_LW = 1.2            # Linienstärke USB-Pfeile

COLOR_NODE = "black"
COLOR_EDGE = "green"
COLOR_WRAP = "orange"
COLOR_IN   = "#1f77b4"  # blau
COLOR_OUT  = "#d62728"  # rot
COLOR_BOX  = "black"     # Farbe für die Bounding Box

ELEV = 25               # Kamerawinkel
AZIM = -60

# ---------------- Hilfsfunktionen ----------------
def unit(v):
    v = np.asarray(v, dtype=float)
    n = np.linalg.norm(v)
    return v / (n + 1e-12)

def add_bidirectional_link(ax, p0, p1, color=COLOR_EDGE, lw=EDGE_W, ls='-'):
    """Zeichnet Linie + zwei Pfeilköpfe (an beiden Enden) im 3D."""
    p0 = np.array(p0, float); p1 = np.array(p1, float)
    # Hauptlinie
    ax.plot([p0[0], p1[0]], [p0[1], p1[1]], [p0[2], p1[2]], color=color, lw=lw, ls=ls)
    # Richtung
    u = unit(p1 - p0)
    # Pfeilkopf nahe p1 (zeigt p0->p1)
    start1 = p1 - u * (ARHEAD * 1.2)
    ax.quiver(start1[0], start1[1], start1[2], u[0], u[1], u[2],
              length=ARHEAD, arrow_length_ratio=0.4, color=color, lw=lw, normalize=False)
    # Pfeilkopf nahe p0 (zeigt p1->p0)
    start0 = p0 + u * (ARHEAD * 1.2)
    ax.quiver(start0[0], start0[1], start0[2], -u[0], -u[1], -u[2],
              length=ARHEAD, arrow_length_ratio=0.4, color=color, lw=lw, normalize=False)

def bezier_quad(p0, c, p1, t):
    """Quadratische Bézier-Kurve im 3D."""
    p0, c, p1 = map(np.asarray, (p0, c, p1))
    return (1-t)**2 * p0 + 2*(1-t)*t * c + t**2 * p1

def bezier_quad_tangent(p0, c, p1, t):
    """Tangent (Ableitung) der quadratischen Bézier-Kurve bei t."""
    p0, c, p1 = map(np.asarray, (p0, c, p1))
    return 2*(1-t)*(c - p0) + 2*t*(p1 - c)

def add_wrap_bezier_bidirectional(ax, p0, p1, ctrl, color=COLOR_WRAP, lw=WRAP_W, ls='--', npts=100):
    """Gekrümmte, gestrichelte Wrap-Kante mit Pfeilköpfen an beiden Richtungen."""
    ts = np.linspace(0, 1, npts)
    pts = np.array([bezier_quad(p0, ctrl, p1, t) for t in ts])
    ax.plot(pts[:,0], pts[:,1], pts[:,2], color=color, lw=lw, ls=ls)
    # Pfeilkopf in Start-Richtung (t klein)
    t0 = 0.10
    P0 = bezier_quad(p0, ctrl, p1, t0)
    T0 = unit(bezier_quad_tangent(p0, ctrl, p1, t0))
    ax.quiver(P0[0], P0[1], P0[2], T0[0], T0[1], T0[2],
              length=ARHEAD, arrow_length_ratio=0.4, color=color, lw=lw, normalize=False)
    # Pfeilkopf in End-Richtung (t groß, rückwärts)
    t1 = 0.90
    P1 = bezier_quad(p0, ctrl, p1, t1)
    T1 = unit(bezier_quad_tangent(p0, ctrl, p1, t1))
    ax.quiver(P1[0], P1[1], P1[2], -T1[0], -T1[1], -T1[2],
              length=ARHEAD, arrow_length_ratio=0.4, color=color, lw=lw, normalize=False)

def add_usb_io(ax, xy, up=H, color_in=COLOR_IN, color_out=COLOR_OUT):
    """USB-IN (blau) von oben -> Knoten, USB-OUT (rot) vom Knoten nach unten."""
    x, y = xy
    # IN: (x,y,H) -> (x,y,0)
    ax.quiver(x, y, H, 0, 0, -H, length=1.0, color=color_in, lw=USB_LW,
              arrow_length_ratio=0.12, normalize=False, alpha=0.5)
    # OUT: (x,y,0) -> (x,y,-H)
    ax.quiver(x, y, 0, 0, 0, -H, length=1.0, color=color_out, lw=USB_LW,
              arrow_length_ratio=0.12, normalize=False, alpha=0.5)

# ---------------- Szene aufbauen ----------------
fig = plt.figure(figsize=(9,8))
ax = fig.add_subplot(111, projection='3d')
ax.view_init(elev=ELEV, azim=AZIM)

# Grid-Layout (z=0) und Knoten zeichnen
pos = {}
for r in range(N):
    for c in range(N):
        x, y, z = c, (N-1-r), 0.0
        pos[(r,c)] = np.array([x,y,z])
        ax.plot([x], [y], [z], marker='o', ms=NODE_MS,
                markerfacecolor='white', markeredgecolor=COLOR_NODE, markeredgewidth=1.5)

# Lokale bidirektionale Kanten (E und S, um Doppelungen zu vermeiden)
for r in range(N):
    for c in range(N):
        p = pos[(r,c)]
        if c < N-1:  # East
            q = pos[(r,c+1)]
            add_bidirectional_link(ax, p + np.array([0.12,0,0]), q - np.array([0.12,0,0]),
                                   color=COLOR_EDGE, lw=EDGE_W, ls='-')
        if r < N-1:  # South
            q = pos[(r+1,c)]
            add_bidirectional_link(ax, p - np.array([0,0.12,0]), q + np.array([0,0.12,0]),
                                   color=COLOR_EDGE, lw=EDGE_W, ls='-')

# Wrap-around horizontal (rechts -> links je Zeile)
pad = 0.55
ymax = (N-1) + 0.0
for r in range(N):
    pR = pos[(r, N-1)] + np.array([+0.12,0,0])
    pL = pos[(r, 0)]   - np.array([+0.12,0,0])
    ctrl = np.array([(pR[0]+pL[0])/2, ymax + pad, 0.0])  # leicht oberhalb der Box
    add_wrap_bezier_bidirectional(ax, pR, pL, ctrl, color=COLOR_WRAP, lw=WRAP_W, ls='--')

# Wrap-around vertikal (unten -> oben je Spalte)
xmax = (N-1) + 0.0
for c in range(N):
    pB = pos[(N-1, c)] - np.array([0,0.12,0])
    pT = pos[(0,    c)] + np.array([0,0.12,0])
    ctrl = np.array([xmax + pad, (pB[1]+pT[1])/2, 0.0])  # rechts neben der Box
    add_wrap_bezier_bidirectional(ax, pB, pT, ctrl, color=COLOR_WRAP, lw=WRAP_W, ls='--')

# USB I/O an jedem Knoten (orthogonal zur Ebene)
for r in range(N):
    for c in range(N):
        xy = pos[(r,c)][:2]
        add_usb_io(ax, xy, up=H, color_in=COLOR_IN, color_out=COLOR_OUT)

# Add bounding box edges
x_min, x_max = -0.8, N-1+0.8
y_min, y_max = -0.8, N-1+0.8
z_min, z_max = -H-0.4, H+0.7

# Define corners of the bounding box
corners = [
    (x_min, y_min, z_min), (x_max, y_min, z_min),
    (x_min, y_max, z_min), (x_max, y_max, z_min),
    (x_min, y_min, z_max), (x_max, y_min, z_max),
    (x_min, y_max, z_max), (x_max, y_max, z_max),
]

# Define edges of the bounding box by connecting corners
edges = [
    (0, 1), (0, 2), (0, 4),
    (1, 3), (1, 5),
    (2, 3), (2, 6),
    (3, 7),
    (4, 5), (4, 6),
    (5, 7),
    (6, 7),
]

# Draw the edges
for i, j in edges:
    p0 = corners[i]
    p1 = corners[j]
    ax.plot([p0[0], p1[0]], [p0[1], p1[1]], [p0[2], p1[2]], color=COLOR_BOX, linestyle='-', linewidth=0.7, alpha=0.4)


# Achsen & Limits
ax.set_xlim(x_min, x_max)
ax.set_ylim(y_min, y_max)
ax.set_zlim(z_min, z_max)
ax.set_xticks([]); ax.set_yticks([]); ax.set_zticks([])

# Legende
legend_lines = [
    Line2D([0],[0], color=COLOR_EDGE, lw=EDGE_W, label="Local Edge (bidirectional)"),
    Line2D([0],[0], color=COLOR_WRAP, lw=WRAP_W, ls='--', label="Wrap-around (bidirectional)"),
    Line2D([0],[0], color=COLOR_IN,  lw=USB_LW, label="USB IN (from above)"),
    Line2D([0],[0], color=COLOR_OUT, lw=USB_LW, label="USB OUT (downwards)"),
    Line2D([0],[0], color=COLOR_BOX, lw=0.7, label="Bounding Box"),
]
ax.legend(handles=legend_lines, loc='upper left', bbox_to_anchor=(0.02, 0.98))

ax.set_title("RFFG 3×3 2D-Torus (3D View): USB IN/OUT Orthogonal, Bidirectional Edges", pad=16)

plt.tight_layout()
plt.savefig("RFFG_torus3x3_io_3D.pdf")
plt.savefig("RFFG_torus3x3_io_3D.png", dpi=300)
print("Saved: RFFG_torus3x3_io_3D.pdf / RFFG_torus3x3_io_3D.png")

# Anzeige (interaktiv in Colab drehbar)
plt.show()